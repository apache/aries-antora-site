Title: SPI Fly

#SPI Fly#

This page describes the SPI Fly component.
The SPI Fly component is aimed at providing general support for the JRE SPI
mechanism, including the usage of <tt>java.util.ServiceLoader</tt>, 
<tt>META-INF/services</tt> and similar methods in OSGi.


##The Problem##
<tt>java.util.ServiceLoader.load()</tt> and other similar methods such as 
<tt>sun.misc.Service.providers()</tt>, but also other static finder methods such as the 
<tt>FactoryFinder.find()</tt> methods try to locate 'service' implementations by looking for 
resources in the META-INF/services directory of all the jars visible to the 
***Thread Context ClassLoader*** (TCCL).

There are a number of issues with this approach in OSGi:

 1. The Thread Context ClassLoader is not defined in general in an OSGi context. It can and has to be set by the caller and OSGi cannot enforce that. 
 2. A bundle can't Import-Package META-INF/services as potentially many bundles will contain this pseudo-package and the OSGi framework will only bind a single exporter to an importer for a given package.
 3. Instantiating an SPI provider generally requires access to internal implementation classes, by exporting these classes an implementing bundle would break its encapsulation. 
 4. Even if an implementation class was exported, importing this class in a consumer bundle would bind it to the specific implementation package provided, which violates the principle of loose coupling.
 5. Bundles have a dynamic life-cycle which means that provided services could disappear when a bundle is updated or uninstalled. The java.util.ServiceLoader API does not provide a mechanism to inform service consumers of such an event.

The SPI Fly project makes it possible to use existing code that uses 
<tt>ServiceLoader.load()</tt> and similar mechanisms under OSGi.

##Making it Work##
In order to make the ServiceLoader approach work under OSGi, calling code can be woven
to set the TCCL to the appropriate providers very briefly, only for the duration of the
call. The SPI Fly component does precisely this.

###Providers###
First for all, SPI Fly needs to be made aware of any bundles that provide the services.
These bundles are made visible through the TCCL for the duration of the <tt>ServiceLoader.load()</tt>
(or similar) call.

To mark a bundle as a Provider, set the **<tt>SPI-Provider</tt>** manifest header:

* **SPI-Provider: *** will consider all providers found in the META-INF/services
directory and register them.
* **SPI-Provider: org.acme.MySvc1, org.acme.MySvc2** will only consider MySvc1 and
MySvc2.

Additionally services found in META-INF/services are registered in the OSGi Service 
Registry. Each service is registered with the *spi.provider.url* service registration
property.

The <tt>SPI-Provider</tt> header can either be set in the providing bundle itself or in a wrapper bundle
that holds the original unmodified jar containing the provider internally as a 
on the <tt>Bundle-ClassPath</tt>.

###Consumers###
Service consumers also need to opt-in to the process. 

To specify a consumer, add the <tt>SPI-Consumer</tt> manifest header to the client bundle. This header 
will opt-in the bundle to the weaving process where for the duration of the specified call
the TCCL will be set to the matching provider bundle(s).

* **SPI-Consumer: *** This is a shorthand for 
<tt>java.util.ServiceLoader#load(java.lang.Class)</tt> and will 
automatically weave all <tt>ServiceLoader.load(Class)</tt> calls.
* **java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI])**
Only process calls to <tt>ServiceLoader.load(Class)</tt> when it is called with 
<tt>MySPI.class</tt> as argument.
* **javax.xml.parsers.DocumentBuilderFactory#newInstance()** weave clients that
call <tt>DocumentBuilderFactory.newInstance()</tt>. 
* **org.foo.Foo#someMthd(),org.bar.Bar#myMethod()** weave calls to <tt>Foo.someMthd()</tt> and 
<tt>Bar.myMethod()</tt>. 


There are currently standardization efforts ongoing in the OSGi Alliance for which the SPI Fly project is the Reference Implementation. 
For more information, see RFC 167 in the OSGi Enterprise 5 EA draft: 
[http://www.osgi.org/download/osgi-early-draft-2011-09.pdf][1]

The code can be found in
[http://svn.apache.org/repos/asf/aries/trunk/spi-fly][2].

##How to use##
There are currently two ways to use the SPI Fly component. If you have an OSGi 
4.3 compliant framework that supports WeavingHooks you can use the dynamic weaving approach. 

If you have an pre-4.3 OSGi framework or don't want to use bytecode weaving at runtime you 
can use the static weaving approach.

##Use with Dynamic Weaving##
Install and start the <tt>org.apache.aries.spifly.dynamic.bundle</tt> into the system. This bundle 
has a dependency on <tt>[org.objectweb.asm][3]</tt> version 3.2 or newer and on the Aries 
Util bundle.

<pre>osgi> ss    
Framework is launched.    
id	State       Bundle
0	ACTIVE      org.eclipse.osgi_3.7.1.R37x_v20110808-1106
1	ACTIVE      org.objectweb.asm.all_3.2.0
2	ACTIVE      org.apache.aries.util_0.5.0.SNAPSHOT
3	ACTIVE      org.apache.aries.spifly.dynamic.bundle_0.4.0.SNAPSHOT
</pre>

Note that, as with any OSGi Bundle that uses the OSGi 4.3 WeavingHooks, the weaver
bundle (<tt>org.apache.aries.spifly.dynamic.bundle</tt> in the SPI Fly case) needs to 
be active before any bundles that need to be dynamically woven. OSGi Start Levels can
provide a mechanism to control this.

##Use with Static Weaving##
For static use, you need to weave the client bundle before installing it into the system. 
The modification changes the byte code around java.util.ServiceLoader.load() calls in the 
bundle and inserts calls to set the correct ThreadContextClassLoader around it.
Provider bundles are still handled dynamically.

###To statically weave a bundle###
The easiest way to invoke the static weaver is to take the <tt>org.apache.aries.spifly.static.tool</tt>
jar with dependencies. This jar can be created by running <tt>mvn assembly:single</tt> in this maven module.

Then run the static tool on any bundle that needs processing:
<pre>
java -jar org.apache.aries.spifly.static.tool-0.4-with-dependencies.jar mybundle.jar
</pre>

This will produce a second bundle with the same name with the _spifly suffix appended, so 
in this case the generated bundle will be called mybundle_spifly.jar.

At runtime, install the <tt>org.apache.aries.spifly.static.bundle</tt> into the system, like
the dynamic weaving bundle it has a dependency on the Aries Util bundle:
<pre>osgi> ss
Framework is launched.
id	State       Bundle
0	ACTIVE      org.eclipse.osgi_3.6.2.R36x_v20110210
1	ACTIVE      org.eclipse.osgi.services_3.2.100.v20100503
2	ACTIVE      org.apache.aries.util_0.5.0.SNAPSHOT
3	ACTIVE      org.apache.aries.spifly.static.bundle_0.4.0.SNAPSHOT</pre>

Then install and start the statically woven bundle into the system.

##Special Cases##
SPI Fly can be used for most SPI provider/lookup systems that use the TCCL pattern to obtain
implementations. However, some cases some *special treatment* is needed. This section
lists the known cases.

  - **javax.imageio.spi.ServiceRegistry**: This class is very much like
java.util.ServiceLoader in that it can load any kind of API implementation.
While SPI Fly knows about ServiceLoader and treats it specially, the ServiceRegistry
class currently does not have special treatment. It can still be made to work
but this requires the following header in the provider bundle:
<tt>SPI-Provider:&nbsp;javax.imageio.spi.ServiceRegistry</tt>


##Examples##
The <tt>spi-fly-examples</tt> directory contains a number of example bundles that can be 
used for testing or experimenting.

The following modules can be found in this directory:

* **spi-fly-example-spi-bundle** - a bundle providing an SPI interface used by the other example bundles.
* **spi-fly-example-provider1-jar** - a plain jar file providing an implementation of the SPI (via <tt>META-INF/services</tt>).
* **spi-fly-example-provider1-bundle** - a bundle that wraps the jar file from the previous bullet and specifies it in its Bundle-ClassPath. This example represents the common case where an existing SPI provider is wrapped as-is in an OSGi bundle.
* **spi-fly-example-provider2-bundle** - a bundle that directly provides an SPI service (via <tt>META-INF/services</tt>).
* **spi-fly-example-client1-jar** - a plain jar using java.util.ServiceLoader.load() to obtain and invoke all services provided of a certain SPI.
* **spi-fly-example-client1-bundle** - a bundle that wraps the jar file from the previous bullet and lists it in its Bundle-ClassPath. This example represents the common case where an existing SPI consumer is wrapped as-is in an OSGi bundle.
* **spi-fly-example-client2-bundle** - a bundle that has code that invokes <tt>java.util.ServiceLoader.load()</tt> directly.


  [1]: http://www.osgi.org/download/osgi-early-draft-2011-09.pdf
  [2]: http://svn.apache.org/repos/asf/aries/trunk/spi-fly
  [3]: http://search.maven.org/#artifactdetails|asm|asm-all|3.2|jar